@page "/draft"
@rendermode InteractiveServer
@using AkdTimerGV.Components.Models
@using Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage
@using System.Threading
@using System.Text
@inject ProtectedLocalStorage BrowserStorage;
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager;
@inject ILogger<DraftFlow> Logger

<!-- 
    Screen for the Drafting Process, functions based on an internal State machine.
    Current state is dictated by DraftState.FlowState.


-->

<div class="d-flex flex-column">

    <div style="width: 100%">
        <input type="button" value="Reset Drafting Process" onclick="@(() => DraftStateHolder.GetDraftState().Reset())" />
    </div>

    @if (DraftStateHolder == null) {

    } else {
        @if (DraftFlowState.ENTER_PARTICIPANTS == DraftStateHolder.GetDraftState().FlowState) {
            <!-- Start , If using the non-timer version, must manually enter the participants.-->
            <textarea @bind="EnteredParticipants"/>
            <input type="button" value="Continue" onclick="@(() => ConfirmParticipants())" />

        } else if (DraftFlowState.INITIALIZE_DRAFT_ORDER == DraftStateHolder.GetDraftState().FlowState) {
            <!-- Start State b, allow user to initially roll the Draft Order -->
            <input style="vertical-align:middle; font-size: 4em;" type="button" value="Randomize Order" onclick="@(() => DraftStateHolder.GetDraftState().InitializeDraftOrder(DraftStateHolder.GetParticipants()))" />
        } else if (DraftFlowState.ORDER_RANDOMIZED == DraftStateHolder.GetDraftState().FlowState) {
            <!-- Second State, Draft Order has been rolled, Display it and allow them to re-roll or continue.-->
            @for (int i = 0; i < DraftStateHolder.GetDraftState().RandomizedDraftOrder.Count(); i++) {
                <h2>@(i + 1 + " - " + DraftStateHolder.GetDraftState().RandomizedDraftOrder[i])</h2>
            }

            <input type="button" value="Reroll" onclick="@(() => DraftStateHolder.GetDraftState().RerollOrder())" />
            <input type="button" value="Continue" onclick="@(() => ConfirmOrderRandomization())" />
        } else if (DraftFlowState.CHOOSE_GAME == DraftStateHolder.GetDraftState().FlowState) {
            <!-- 
                Third State, Draft Order has been decided, Let the users choose the games to add to the draft, either via checkboxes, or via the tiermaker code system.
                It's fully compatible with the code system from the FE Tier Maker
            .-->
            <span>Choose games to add</span>


            <!-- Option 1: Select via Checkboxes -->
            <div class="d-grid">
                @foreach (String groupingKey in DraftStateHolder.GetDraftState().ChosenGameDict.Keys) {
                    var grouping = DraftCharacterCache.DraftGroupings[groupingKey];
                    <div style="grid-row: @grouping.Row; grid-column: @grouping.Column">
                        <input type="checkbox" @bind="DraftStateHolder.GetDraftState().ChosenGameDict[grouping.InternalName]" @bind:after="(() => DraftStateHolder.GetDraftState().NotifySubscribers())" /> @grouping.Name
                    </div>
                }
            </div>
                
            <input type="button" value="Unselect all" onclick="@(() => DraftStateHolder.GetDraftState().ResetSelectedGames())" />
            <input type="button" value="Load selected Rosters" onclick="@(() => ConfirmGameSelection())" />

            <hr />
            <!-- Option 2: Load via Code -->
            <h1>OR</h1>
            <hr />
            <textarea @bind="TiermakerCode" rows="5"/>
            <input type="button" value="Load via code" onclick="@(() => LoadTiermakerCode())" />

        } else if (DraftFlowState.DRAFTING_STARTED == DraftStateHolder.GetDraftState().FlowState) {
            <!--
                Fourth State, the games have been chosen, so the draft can begin
            .-->
            <div class="d-flex flex-column">
                <!-- Table containing the Auto generated Draft Tiers -->
                <div style="background-color: #1A1A1A; margin: 30px auto 30px auto">
                    <table>
                        @foreach (DraftGrouping draftGrouping in DraftGroupings) {
                            <tr class="flex-container" style="border: 3px solid black;">
                                <td class="draft-label-holder">
                                    <textarea style="border:none; background-color: #1A1A1A; text-align: center; width: auto; resize:none;" value="@draftGrouping.Name" />
                                </td>

                                <td style="width: 640px; height: 64px;">
                                        <!--<Dropzone Items="draftGrouping.Characters" TItem="DraftCharacter" OnItemDrop="@(() => CommitChanges(true))" >-->
                                        <Dropzone ItemWrapperClass="@(item => "grid-item")" Items="draftGrouping.Characters" TItem="DraftCharacter" OnItemDrop="@(() => CommitChanges(true))">
                                        <ChildContent><div class="draft-character-image" style="background-image:url('@context.ImagePath') !important;" /></ChildContent>
                                    </Dropzone>
                                </td>
                            </tr>
                        }
                    </table>
                </div>

                <!-- Other available characters -->
                <div class="d-flex flex-row" style="margin: 10px auto 40px; width: 1024px;">
                    <Dropzone ItemWrapperClass="@(item => "grid-item")" Items="availableCharacters.Characters" TItem="DraftCharacter" OnItemDrop="@(() => CommitChanges(true))">
                        <ChildContent><div class="draft-character-image" style="background-image:url('@context.ImagePath') !important;" /></ChildContent>
                    </Dropzone>
                </div>

                <!-- Some other Controlls and options -->
                <input type="button" value="Commit changes" onclick="@(() => CommitChanges(false))" />
                <span><input type="checkbox" @bind="AutoCommit" /> Automatic Commit</span>
                <span><input type="checkbox" @bind="SuppressAutoRefresh" /> Suppress refreshes</span>
                <input type="button" value="Manual refresh" onclick="@(() => refreshFromDraftState(false))" />
                @if (DraftStateHolder is Lobby) {
                    <input type="button" value="End Draft" onclick="@(() => FinishDraft())" />
                } else {
                    <input type="button" value="End Draft" onclick="@(() => FinishDraft())" />
                }
                <div class="d-flex flex-column" style="margin-top: 10px">
                    <span><input type="checkbox" @bind="ExportIncludingParticipants" /> Include Participants <input type="button" value="Generate Tiermaker Code" onclick="@(() => ExportToTiermakerCode())"/></span>
                    <span><textarea @bind="TiermakerCode" cols="35"/></span>
                </div>
            </div>

        }
    }
</div>

@code {
    private IDraftStateHolder DraftStateHolder { get; set; }
    private User currentUser { get; set; }
    private bool namesSet = false;
    private Timer Timer;
    // The Draft Groupings displayed to the user are always read from this local maps. These local values are ALWAYS clones, not references, from the ones in the Draft State.
    // This is to facilitate the option to not auto-commit
    private List<DraftGrouping> DraftGroupings = [];
    private DraftGrouping availableCharacters;

    private bool AutoCommit = true;
    private bool SuppressAutoRefresh = false;
    private string TiermakerCode;
    private string EnteredParticipants;

    private bool ExportIncludingParticipants = false;

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (!firstRender) {
            if (DraftStateHolder != null) {
                // Automatically redirect to the lobby page at the end of the draft
                if (DraftStateHolder.GetDraftState().FlowState == DraftFlowState.DRAFTING_FINISHED  && DraftStateHolder is Lobby) {
                    NavigationManager.NavigateTo("/timer/lobby");
                    return;
                }

                // Subscribe to the Draft State, so that anytime changes are commited, the screen gets refreshed
                DraftStateHolder.GetDraftState().Subscribe(this);
            }
            return;
        }

        // First try to find if the user is currently already in a lobby for determining the DraftStateHolder
        DraftStateHolder = await getStoredLobby();
        currentUser = await getStoredUser();
        if (DraftStateHolder == null) {
            // Next try to find a stored IndependentDraftStateHolder
            DraftStateHolder = await getStoredIndependentDraftState();
            if (DraftStateHolder == null) {
                BrowserStorage.DeleteAsync("DraftLobby");
                DraftStateHolder = DraftLobbyHolder.Instance.CreateIndependentDraftStateHolder();
                await BrowserStorage.SetAsync("DraftLobby", DraftStateHolder.GetId());
            }
        }

        refreshFromDraftState(false);
        StateHasChanged();
    }

    /// <summary>
    /// Get the LobbyId from the Local Storage
    /// </summary>
    /// <returns></returns>
    private async Task<Lobby?> getStoredLobby() {
        var storedLobby = await BrowserStorage.GetAsync<Guid>("currentLobby");
        Guid? currentLobbyId = storedLobby.Value;
        if (currentLobbyId == null) {
            return null;
        }

        // if the data of the Locally stored lobby is no longer present,
        // then remove the locally saved Lobby id and switch to the main page
        return LobbyHolder.Instance.getLobby((Guid)currentLobbyId);
    }

    /// <summary>
    /// Get the LobbyId from the Local Storage
    /// </summary>
    /// <returns></returns>
    private async Task<DraftLobby?> getStoredIndependentDraftState() {
        var storedDraftState = await BrowserStorage.GetAsync<Guid>("DraftLobby");
        Guid? currentDraftStateId = storedDraftState.Value;
        if (currentDraftStateId == null) {
            return null;
        }

        // if the data of the Locally stored lobby is no longer present,
        // then remove the locally saved Lobby id and switch to the main page
        return DraftLobbyHolder.Instance.GetById((Guid)currentDraftStateId);
    }

    /// <summary>
    /// Get the User from the Local Storage
    /// </summary>
    /// <returns></returns>
    private async Task<User?> getStoredUser() {
        var storedUser = await BrowserStorage.GetAsync<Guid>("user");
        Guid? currentUser = storedUser.Value;
        if (currentUser == null) {
            return null;
        }

        // if the data of the Locally stored lobby is no longer present,
        // then remove the locally saved Lobby id and switch to the main page
        return UserHolder.GetUserById((Guid)currentUser);
    }

    ///  <summary>
    /// When user confirms the order, create the DraftGroupings
    /// </summary>
    private void ConfirmParticipants() {
        DraftStateHolder.GetDraftState().AdvanceState();
        ((DraftLobby) DraftStateHolder).SetParticipants(EnteredParticipants.Split("\n"));
    }

    ///  <summary>
    /// When user confirms the order, create the DraftGroupings
    /// </summary>
    private void ConfirmOrderRandomization() {
        DraftStateHolder.GetDraftState().AdvanceState();
        foreach (String team in DraftStateHolder.GetDraftState().RandomizedDraftOrder) {
            DraftGrouping teamGrouping = new DraftGrouping(team);
            teamGrouping.IsPlayer = true;
            DraftStateHolder.GetDraftState().DraftGroupings.Add(team, teamGrouping);
        }
        refreshFromDraftState(false);
    }

    /// <summary>
    /// Confirm the game selection, this resets the List of available characters AND all the already drafted characters
    /// </summary>
    private void ConfirmGameSelection() {
        List<DraftCharacter> draftCharacters = [];

        foreach (KeyValuePair<String, Boolean> game in DraftStateHolder.GetDraftState().ChosenGameDict) {
            if (game.Value) {
                draftCharacters.AddRange(DraftCharacterCache.DraftGroupings[game.Key].Characters);
            }
        }

        DraftStateHolder.GetDraftState().SetAvailableCharacters(draftCharacters);

        // Remove all the Characters from the DraftGroupings where the game is not in the Selected Games
        List<String> SelectedGameShortNames = DraftStateHolder.GetDraftState().ChosenGameDict.Where(pair => pair.Value == false).Select(pair => pair.Key).ToList();
        foreach (DraftGrouping grouping in DraftStateHolder.GetDraftState().DraftGroupings.Values) {
            grouping.Characters.RemoveAll(chara => SelectedGameShortNames.Contains(chara.ShortName.Split("-")[0]));

        }
        DraftStateHolder.GetDraftState().AdvanceState();
    }

    /// <summary>
    /// Load the Tiermaker code, this shares the format with the original TierMaker
    /// 
    /// Always starts by fe==
    /// 
    /// Then following format:
    /// TierName|ColorIndex (unused in this tool)|CharacterShortName|CharacterShortName|.....==
    /// 
    /// All Values are separated by |
    /// A new Tier is started by an ==
    /// 
    /// </summary>
    private void LoadTiermakerCode() {
        if (!TiermakerCode.StartsWith("fe")) {
            return;
        }

        // Example code: fe==Free|0|eng-6|eng-5==Banned|1|eng-7
        // can ignore first FE== free
        // After split by == so we have each tier in a separate string.
        // Then split by |
        // index = tier name, index = 1 color (can ignore), after character shortnames
        String[] tiers = TiermakerCode.Substring(4).Split("==");
        List<String> charactersToMove = [];

        List<DraftGrouping> NewGroupings = [];

        // Step 1:
        // Unselect all games to reset available characters / groupings to empty
        DraftStateHolder.GetDraftState().ResetSelectedGames();
        ConfirmGameSelection();

        // Step 2:
        // Iterate through the tiers from the code in the and build up the pre-made tiers to add after the player tiers.
        // Initially they are only added to a local list, not to the draft state, as we are reusing the code for selecting a game to load the available characters
        // Additionally track a List of characters that must be removed from the available characters.
        foreach (String tier in tiers) {
            String[] Components = tier.Split("|");
            DraftGrouping groupingToAdd = new DraftGrouping(Components[0]);
            NewGroupings.Add(groupingToAdd);
            for (int i = 2; i < Components.Length; i++) {
                String ShortName = Components[i];
                String GameShortName = ShortName.Split("-")[0];
                int CharacterIndex = int.Parse(ShortName.Split("-")[1]);

                DraftStateHolder.GetDraftState().ChosenGameDict[GameShortName] = true;
                charactersToMove.Add(ShortName);
                groupingToAdd.Characters.Add(DraftCharacterCache.DraftGroupings[GameShortName].Characters[CharacterIndex]);
            }
        }

        // Step 2:
        // Trigger game selection logic again to build up available characters
        ConfirmGameSelection();

        // Step 3:
        // After game selection logic, add the newly created groupings, and remove the characters contained within those groupings from the available characters
        foreach (DraftGrouping draftGrouping in NewGroupings) {
            DraftStateHolder.GetDraftState().DraftGroupings.Add(draftGrouping.Name, draftGrouping);
        }
        DraftStateHolder.GetDraftState().AvailableCharacters.Characters.RemoveAll(dc => charactersToMove.Contains(dc.ShortName));
        DraftStateHolder.GetDraftState().NotifySubscribers();
        TiermakerCode = "";
    }

    private void ExportToTiermakerCode() {
        StringBuilder builder = new StringBuilder();
        builder.Append("fe");
        foreach (DraftGrouping grouping in DraftGroupings) {
            // If user doesn't explicitly want to export the participants, just skip them.
            if (grouping.IsPlayer && !ExportIncludingParticipants) {
                continue;
            }

            builder.Append("==");
            builder.Append(grouping.IsPlayer ?  grouping.InternalName : grouping.Name);
            // Color unused, just always put 0
            builder.Append("|0");
            foreach (DraftCharacter chara in grouping.Characters) {
                builder.Append("|").Append(chara.ShortName);
            }

        }

        TiermakerCode = builder.ToString();
        StateHasChanged();
    }

    /// <summary>
    /// Finalize the draft.
    /// Advances the FlowState to the final state. Also copies the draft to the TimerData if the draft is for a Timer Lobby
    /// </summary>
    private void FinishDraft() {

        if (DraftStateHolder is Lobby) {
            foreach (DraftGrouping dg in DraftStateHolder.GetDraftState().DraftGroupings.Values) {
                Team? team = ((Lobby) DraftStateHolder).GetTeamByName(dg.InternalName);
                if (dg.IsPlayer && team!=null) {
                    team.TimerData.DraftedCharacters = dg.Characters;
                }
            }
        }

        DraftStateHolder.GetDraftState().AdvanceState();
    }

    /// <summary>
    /// Commits the changes in the local representation of the 
    /// </summary>
    public void CommitChanges(bool automatic) {
        if (automatic && !AutoCommit) {
            return;
        }
        DraftStateHolder.GetDraftState().UpdateState(DraftGroupings, availableCharacters);
    }

    /// <summary>
    /// reload the local state from the shared state, unless it's an automatic refresh and this an automatically triggered refresh by the DraftState subscription.
    /// </summary>
    public void refreshFromDraftState(bool automatic) {
        InvokeAsync(() => {
            if (automatic && SuppressAutoRefresh) {
                return;
            }

            DraftGroupings = DraftStateHolder.GetDraftState().DraftGroupings.Values.Select(value => value.clone()).ToList();
            availableCharacters = DraftStateHolder.GetDraftState().AvailableCharacters.clone();
            StateHasChanged();
        });
    }

    ///  <summary>
    /// When this object is disposed, unsubscribe from the DraftState
    /// </summary>
    public void Dispose() {
        if (DraftStateHolder != null) {
            DraftStateHolder.GetDraftState().Unsubscribe(this);
        }
    }
}
